#!/usr/bin/env node

import fs from "fs";
import path from "path";
import { fileURLToPath } from "url";

// Get current directory for ES modules
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Define paths relative to project root
const projectRoot = path.resolve(__dirname, "..");
const schemasDir = path.join(projectRoot, "convex", "schemas");
const barrelFile = path.join(schemasDir, "index.ts");

/**
 * Generates barrel file exports for all schema files in the schemas directory
 * Scans for .schema.ts files and creates export statements
 */
function generateBarrelFile() {
  try {
    console.log("üîç Scanning schemas directory for changes...");

    // Read all files in schemas directory
    const files = fs.readdirSync(schemasDir);

    // Filter for schema files (exclude index.ts and non-schema files)
    const schemaFiles = files
      .filter((file) => file.endsWith(".schema.ts"))
      .sort(); // Sort alphabetically for consistent output

    if (schemaFiles.length === 0) {
      console.log("‚ö†Ô∏è  No schema files found in schemas directory");
      return;
    }

    // Generate export statements
    const exports = schemaFiles.map((file) => {
      const moduleName = file.replace(".ts", "");
      return `export * from "./${moduleName}";`;
    });

    // Add final newline for clean formatting
    const content = exports.join("\n") + "\n";

    // Read current barrel file content to check if update is needed
    let currentContent = "";
    if (fs.existsSync(barrelFile)) {
      currentContent = fs.readFileSync(barrelFile, "utf8");
    }

    // Only write if content has changed
    if (currentContent !== content) {
      fs.writeFileSync(barrelFile, content, "utf8");
      console.log("‚úÖ Updated barrel file with the following exports:");
      console.log();
      schemaFiles.forEach((file) => console.log(`   üìÑ ${file}`));
      console.log();
      console.log(
        `üìÅ Generated ${schemaFiles.length} export${
          schemaFiles.length === 1 ? "" : "s"
        } in index.ts`,
      );
    } else {
      console.log("‚ú® Barrel file is already up to date");
    }
  } catch (error) {
    console.error("‚ùå Error generating barrel file:", error.message);
    process.exit(1);
  }
}

/**
 * Converts schema file names to PascalCase type names
 * Examples: users -> Users, menu_items -> MenuItems, order_item -> OrderItem
 */
function convertToPascalCase(fileName) {
  return fileName
    .split(/[._-]/) // Split on dots, underscores, or hyphens
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
    .join("");
}

/**
 * Reads schema files and generates a comprehensive type file in the project root
 * Creates TypeScript types using Convex's Infer utility for type safety
 */
function generateDBTypeFile() {
  try {
    console.log("üîç Scanning schema files for type generation...");

    // ~ ======= Read all schema files ======= ~
    const files = fs.readdirSync(schemasDir);
    const schemaFiles = files
      .filter((file) => file.endsWith(".schema.ts"))
      .sort();

    if (schemaFiles.length === 0) {
      console.log("‚ö†Ô∏è  No schema files found for type generation");
      return;
    }

    const imports = [];
    const typeDefinitions = [];

    // ~ ======= Process each schema file ======= ~
    console.log();
    for (const file of schemaFiles) {
      const filePath = path.join(schemasDir, file);
      const content = fs.readFileSync(filePath, "utf8");

      // Extract the main export (table definition)
      const exportMatch = content.match(/export const (\w+) = defineTable/);

      if (exportMatch) {
        const exportName = exportMatch[1]; // e.g., "users", "menu_items"
        const fileName = file.replace(".schema.ts", ""); // e.g., "users", "menu.item"

        // Convert to PascalCase type name
        const typeName = convertToPascalCase(exportName);

        // Add import statement
        imports.push(
          `import { ${exportName} } from "./convex/schemas/${fileName}.schema";`,
        );

        // Add type definition using Infer
        typeDefinitions.push(
          `export type ${typeName} = Infer<typeof ${exportName}.validator>;`,
        );

        console.log(`   üìÑ ${file} -> ${typeName}`);
      } else {
        console.log(`   ‚ö†Ô∏è  Could not parse export from ${file}`);
      }
    }
    console.log();

    // ~ ======= Generate complete type file content ======= ~
    const typeFileContent = [
      "// Auto-generated types from Database schemas",
      "// This file is generated by scripts/schema-watch.script.js",
      "",
      'import { type Infer } from "convex/values";',
      "",
      ...imports,
      "",
      ...typeDefinitions,
      "",
    ].join("\n");

    // ~ ======= Write the type file to project root ======= ~
    const typeFilePath = path.join(projectRoot, "db.types.ts");
    fs.writeFileSync(typeFilePath, typeFileContent, "utf8");

    console.log(
      "‚úÖ Generated db.types.ts in project root with the following types:",
    );
    console.log();
    typeDefinitions.forEach((typeDef) => {
      const typeName = typeDef.match(/export type (\w+)/)[1];
      console.log(`   üî∑ ${typeName}`);
    });
    console.log();
    console.log(
      `üìÅ Generated ${typeDefinitions.length} type${typeDefinitions.length === 1 ? "" : "s"} in db.types.ts`,
    );
  } catch (err) {
    console.error("‚ùå Error generating db.types.ts:", err.message);
    process.exit(1);
  }
}

/**
 * Main execution
 * Generates the barrel file and type definitions
 */
function main() {
  console.log("üöÄ Schema watch script started");
  console.log(`üìÇ Watching: ${schemasDir}`);
  console.log(`üìù Barrel target: ${barrelFile}`);
  console.log(`üî∑ Types target: ${path.join(projectRoot, "db.types.ts")}`);
  console.log("‚îÄ".repeat(50));

  generateBarrelFile();

  console.log();
  console.log("‚îÄ".repeat(50));

  generateDBTypeFile();

  console.log();
  console.log("‚îÄ".repeat(50));
  console.log("‚ú® Schema processing complete");
}

// Execute the script
main();
